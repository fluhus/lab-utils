"""Common utilities."""
import gzip
import inspect
import os
import sys
import time
from contextlib import contextmanager
from time import monotonic
from typing import IO, Callable, Iterable

import requests


def printerr(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)


_t: float = None


def is_interactive() -> bool:
    """Indicates whether this run is batch or interactive shell."""
    return hasattr(sys, "ps1")


def flatten(a):
    """Flattens a list or an iterable."""
    if isinstance(a, list):
        return [c for b in a for c in b]
    return (c for b in a for c in b)


_done = 0
_done_t = 0
_done_checkpoints = {10**i for i in range(9)}
_done_checkpoints |= {3 * x for x in _done_checkpoints}


def done(fmt: str = None):
    global _done, _done_t
    if _done == 0:
        _done_t = time.monotonic()
    _done += 1
    if _done in _done_checkpoints:
        if fmt is None:
            fmt = 'Done {} ({:.1f}s)'
        printerr(fmt.format(_done, time.monotonic() - _done_t))


def done_reset():
    global _done
    _done = 0


def mylog(*args):
    fr = inspect.currentframe().f_back
    ln = fr.f_lineno
    fl = fr.f_code.co_filename
    print(f'{fl}:{ln}', file=sys.stderr)
    print('AMIT:', *args, file=sys.stderr)


_TIMTIM_CHECKPOINTS = \
    frozenset(a * (10 ** b) for a in (1, 2, 5) for b in range(10))


class timtim:
    def __init__(self):
        self.t = time.monotonic()
        self.i = 0

    def increment(self):
        self.i += 1
        if self.i in _TIMTIM_CHECKPOINTS:
            print('\r{} ({:.1f}s)'.format(self.i, time.monotonic() - self.t), end='')

    def done(self):
        print('\r{} ({:.1f}s)'.format(self.i, time.monotonic() - self.t))

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.done()


def humanize_seconds(s: float) -> str:
    if s < 0.000001:
        return f'{s*1000000000:.1f}ns'
    if s < 0.001:
        return f'{s*1000000:.1f}us'
    elif s < 1:
        return f'{s*1000:.1f}ms'
    elif s < 60:
        return f'{s:.1f}s'
    elif s < 3600:
        return f'{s/60:.1f}m'
    else:
        return f'{s/3600:.1f}h'


@contextmanager
def timer(prefix=None, n=None):
    t = time.monotonic()
    if prefix is not None:
        print(prefix, end='')
        if n is not None:
            print(f' ({n} items)', end='')
        print()
    yield
    t = time.monotonic() - t
    if prefix is not None:
        print('  --> ', end='')
    print(humanize_seconds(t), end='')
    if n is not None:
        print(f' ({humanize_seconds(t/n)} per item)', end='')
    print()


def get_lnsrv(addr: str, end='END') -> Iterable[str]:
    """Returns lines generated by Line Server (lnsrv) as an iterable."""
    line = requests.get(addr).text.strip()
    while line != end:
        yield line
        line = requests.get(addr).text.strip()


def zopen(path: str, mode: str = 'rt') -> IO:
    """Opens a file for I/O. If path has a gz/gzip suffix, uses the gzip
    library."""
    if path.endswith('.gz') or path.endswith('.gzip'):
        if mode.startswith('w'):
            return gzip.open(path, mode, compresslevel=1)
        return gzip.open(path, mode)
    return open(path, mode)


def benchmark(f: Callable, internal_loop=False):
    """Calls f in a loop and prints timing results."""
    n = 1
    diff = 0
    while diff < 2:
        t = monotonic()
        if internal_loop:
            f(n)
        else:
            for _ in range(n):
                f()
        diff = monotonic() - t
        n = int(n * 1.5 + 0.5)
    print(f'{n} iterations {diff:.1f}s ({diff/n:.1e}s / iteration)')


def assert_type(val, typ):
    if not isinstance(val, typ):
        raise TypeError(f'received type {type(val)}, expected {typ}')


def assert_dtype(val, typ):
    if str(val.dtype) != str(typ):
        raise TypeError(f'received type {val.dtype}, expected {typ}')


def force_remove(f: str):
    try:
        os.remove(f)
    except FileNotFoundError:
        pass  # Ok
